https://docs.google.com/document/d/1MQPBjZcyE5UZWcqWh29fmcoFUmzgmzsgVrzTNKGjMps/edit?usp=sharing





ENGR302 PROGRESS REPORT
Group S4

Arianna Case-Wynyard
Nathan Chamberlain
Jesse Chaisongkhram
Rachel Correa
Lance Shilton









MOTIVATION
Agile is currently in use by 71% of US companies [3]. As one of the top two most popular software development methodologies used by modern technology companies [1], the demand for agile teams is at an all time high. This makes knowledge and experience with Agile a valuable asset for software engineering university students entering the job market, and would allow them to integrate more easily into most tech companies. Additionally to its wide usage among software employers, Agile has quantified, substantial benefits to projects that implement the methodology. [2] In a survey by Ambysoft, it was found that teams using Full Scrum (an Agile subtype) increased their product quality by up to 250%. Members who used agile were 25% more productive, and developed products that are 50% faster to market than non-agile teams [3]. University students who are taught to understand and utilise Agile methodology will not only be more marketable in job-searches, but will be given a tool that is demonstrated to help them attain significantly more productivity and efficiency, and greatly improve the product of their work. Based on the evidence above, educating first-year software engineering students in Agile is highly likely to improve their experience both in the workforce, and their years completing assignments at university, immensely. To facilitate the adoption of Agile, our team is developing a game which will assist students in learning and implementing Scrum.



PROBLEM STATEMENT
44% of Agile projects fail due to the team members lack of experience with Agile methods [4], which makes it imperative that we develop a solution that gives software engineering students the opportunity to both learn and practise Agile if they are to reap the rewards outlined above. Secondly, Waterfall (Agile’s largest competitor in software development methodology) is 15% less successful than Agile [3], yet 37% of Agile projects fail due to the team members feeling external pressure to follow traditional Waterfall practices when working on business technology projects [4]. To counteract this prevalent issue, our team will produce a solution in the form of an educational but enjoyable game centred around encouraging players to utilise Agile methodology. By introducing Agile concepts in a low-stakes, entertaining environment, participants can be relieved of the pressure to follow traditional Waterfall practices so that they may fully embrace Agile methods. The game will solve the problems associated with lack of experience with Agile methods by strongly encouraging students to not only learn the concepts, but to practise them, by both necessitating and rewarding the use of Agile principles. By using this game to address two of the most prominent causes of Agile project failure, participants will be far better equipped to develop software projects effectively.











LITERATURE REVIEW

Chocolate Bar is among the most popular, practical Scrum simulation games in which the product owner relays the customer requirements for a candy bar, and the development team must try to design the chocolate accordingly [14]. At the end of each iteration, the team present the bar, and if it meets the requirements, they win, otherwise the team must record and use the response to inform their changes in the next round. Advantages of Chocolate Bar is that the symbolism and metaphors very clearly correlate to one of the primary principles of Scrum; that software development (the chocolate) should always be continuously guided by changing customer requirements. The game is very clear in what it is attempting to teach, and extremely thorough too, as it involves almost all the key steps of the Scrum process (gathering requirements/organising the backlog, using these to guide the software development in the current sprint, holding a Scrum meeting with stakeholders for feedback, and reviewing feedback to find any necessary changes). Chocolate Bar especially emphasises iteration and feedback, which is an essential part of the project's Agile methodology. However while this game clearly and thoroughly communicates almost all the key aspects of Scrum, it is lacking one of extreme importance: Collaboration. A large reason for Scrum’s success is that it maximises on the knowledge and effort of every member by making a cross-functional team that collaborates and shares every member's resources. Chocolate Bar provides zero significant motivations for collaboration, and therefore is not adequate in teaching what is objectively the main focus of Scrum. Another disadvantage of Chocolate Bar is that while ‘entertaining’ is subjective, the game barely involves any game-like elements common to popular games, and therefore is unlikely to be found entertaining by most players. The problem statement made specific mention that an entertaining environment should be used in Scrum teachings in order to reduce the pressure of using a traditional Waterfall structure when developing software, so by making the correlation between the game and Scrum concepts too clear, Chocolate Bar doesn’t solve this part of the problem. Overall, Chocolate Bar is good at teaching most Scrum concepts, however it is less an entertaining team game, and more just a learning method.

Kanban Pizza is a game that teaches a visualising method of Agile methodology [10]. While our project is taking the Scrum root of Agile, this Agile game has many concepts that are advantageous when adapted to Scrum teachings. The basics of Kanban Pizza are as follows: The game-master designs a pizza slice, then starts a timer and reveals it to the players. The teams must race to make as many accurate replicas as possible before the timer stops at an unknown time. The teams are then introduced to Kanban principles and given 5 minutes to evaluate their efficiency and plan the next round using these principles. The game is rerun and the results are compared so that players can see the difference between working with and without the methodology. Kanban Pizza has some similarities to Chocolate Bar, however it picks up a few aspects that the first game lacks. Most importantly, Kanban Pizza places collaboration, one of Scrum’s core principles, at the forefront of the game. By running a stop clock and hosting competition between the teams, players are given two motivations to find ways to work faster and more effectively, and would soon find that some tasks take much longer than others and therefore would benefit from designating more people to just that role, for example. Along with these collaboration motivators, this game encourages the players to use Agile principles by providing the tools and opportunities to do so, and allowing them to compare the results between rounds. This approach allows players to see the benefits of using Agile, and make the decision to use it, for themselves, differing from Chocolate Bar, which forces the players to follow the ‘iterate and review’ process otherwise they can never finish the game. While putting the choice of utilising Scrum methods into the players hands could result in some being disregarded, it is important that players have the autonomy to experience the effect of using or not using Scrum principles, which enforces the idea that the principles are not just a set of rules to follow, but rather tools that help them achieve better outcomes. The main disadvantage of Kanban Pizza is that it is a Kanban-teaching game, meaning it must be heavily combined with aspects of a more Scrum-centric game, like Chocolate Bar, in order to teach a thorough understanding of all Scrum aspects.

Ball Point is another popular game that teaches Scrum [15]. In this game, the players are given 1+ balls, and the Objective is to pass them to every person in the team as many times as possible within the given timeframe. Each person must receive and pass the ball once for the team to earn one point [16]. After the first round, the team is given time to reflect and review their previous methods/strategies, and plan how they will improve to achieve more points in the next round, before the game is rerun and the scores may be compared. Collaboration and self-organisation are two of the fundamental concepts of Scrum, and Ball Point does an excellent job implementing both these ideas. This solution forces collaboration between every member in the group with the rule that each member must touch the ball once per point, yet does not enforce any rules or guides in how players should  collaborate with each other, leaving the players to organise themselves. Additionally, the time given to evaluate their past performance and future strategies simulates Scrum production process concepts such as retrospectives and sprint planning [15]. Despite these advantages, Ball Point also has some downsides. One issue is that the game doesn’t cover the full Scrum production process, such as gathering and prioritising requirements or the backlog, or the importance of stakeholder feedback. Secondly, the simplicity of the game may somewhat undermine the need for critical thinking and strategizing using Scrum principles. The lack of a challenge more complex than simply passing a ball to each other could easily result in players dismissing the need for a logical approach during their retrospect, and just planning to throw faster in the next round. Therefore, overall this game does little to ensure the teaching of most Scrum principles and is not the most ideal solution.

Our project will be modelled from a combination of the best aspects identified in the Chocolate Bar and Kanban Pizza solutions. Like Chocolate Bar, the game will include:
-        A stand-up Scrum meeting to plan the next sprint (represented by a short period at the start of each round in which the online chat is open for communication).
-        A backlog that must be organised by the players (represented through the generation of varying order recipes).
-        Multiple sprints (represented by each day in the restaurant).
-        Stakeholder feedback (An inspection tool within the game will allow players to verify whether their cooking matches the customer’s order. If it doesn’t, the players will need to either fix it or remake it)
Our game will also meaningingfully differ from Chocolate Bar by incorporating all of the most advantageous Kanban Pizza concepts. These will be used to resolve the limitations found in Chocolate Bar, which were that it didn’t incentivise collaboration, and didn’t involve game elements such as freedom of choice and strategy. Kanban Pizza concepts that will be used, include:
-        A timer will be put on each day, and the time needed to complete each cooking step will vary. This timer will be used to force players to collaborate in order to finish the orders in time, and the variance in time needed for each cooking step will be used to encourage the team to think logically and strategize how they should organise themselves.  
-        Metrics such as cooking time and accuracy will be recorded and presented to the team in a sprint evaluation at the end of each day, allowing the players to see the pros and cons of using or not using Scrum methods.
-        Players will be given opportunities to optimise their cooking process with Scrum principles, but unlike Chocolate Bar, the Scrum principles will be within the players control rather than forced onto them. For example, the stand-up meeting time and food inspection tool will be provided, but players won’t be forced to use them.
In summary, by combining the educative structured Scrum processes from Chocolate Bar with the collaborative, player-controlled elements from Kanban Pizza, the game can provide knowledge and experience for all core Scrum practices, and allow players to discover why they should utilise them and make their own decision to do so, while still being entertaining and not simply setting a rigid process that players must follow without thinking for themselves.






















TOOLS AND METHODS
Unity has been selected to develop the game for several reasons. The game is required to run on the university lab computers, as these are the computers provided to the target audience, however the development team will primarily be creating and running the game on other PC’s with different operating systems. Unity provides the necessary versatility to do so as it is a cross-platform game engine, meaning it can be configured for the game to run on any OS [5]. Unity also has comprehensive formal documentation, and due to its popularity, it has a multitude of unofficial guides/resources catering to the specific functions we desire for our game. Such resources make Unity suitable for our time constraints, as it greatly reduces the time needed to learn and become proficient with the tool, on top of the fact that Unity is considered as one of the best game engines for beginners. Furthermore, Unity is well-known for its user-friendly interface that promotes ease of interacting with the game during development, which will further accelerate development. Unity integrates easily with Git, our projects version control system, and Unity uses C#, which is ideal for this project for the reasons described below.
C# scripts will be used in conjunction with Unity. C# is suited to our purposes over other popular languages like Python or Java due to its well-renowned efficiency and speed, which is especially important for online, multiplayer games such as ours [6]. Additionally, C# is robust due to factors like its strong type safety, and Object-Oriented principles. C# has simpler syntax and is easier to learn than its C++ counterpart, which while being slightly faster, is generally only necessary when creating highly optimised 3D experiences and therefore not required for this 2D game. Additionally to C# possessing simpler syntax, it is quite similar to Java, a language which all team members are very familiar with, which is beneficial in reducing the learning curve [6].
Free asset packs will be utilised to make up a large portion of the GUI including player sprites [11], kitchen utensils [12], food icons [13], etc. The use of asset packs will allow us to implement high quality icons/sprites without compromising time spent on the functional design.
Netcode will be used to facilitate the online, multiplayer functionalities of the game. Netcode for GameObjects is a high-level networking library that’s well-documented, has moderately easy set-up and will handle all of the networking frameworks and low-level protocols for the development team [7], which will save them considerable time and research.
Agile has been adopted for the development process. Agile is the most popular methodology for game development [8], and it has been chosen for this project for several reasons due to:
Agile is based on iterations, with a focus on small, modular commits from all members on a frequent basis [9]. Given that most members of the development team work independently and remotely, this strategy benefits team comprehension by ensuring that members can see, understand and utilise what each other have been working on almost immediately, rather than several days or weeks after it has been finished. Agile methodology will also discourage the team from privately spending too long developing a certain feature or script without integrating it with the main codebase, which results in inflexible code that uses redundant features and doesn’t work. Agile was also chosen because the project requirements often face changes or new additions, and Agile’s iterative nature, focus on prioritised, small commits and short-lived branches greatly increase the groups ability to adapt and remain flexible to these changes.
REQUIREMENTS
Priorities:											     (1 - Essential to game mechanics)								     (2 - Important but not necessary to run)								     (3 - Enhances player experience but is not required)

FUNCTIONAL REQUIREMENTS:
Game Setup & Accessibility
The game must be web-based and accessible via browser. - (Priority: 1)
The game must be multiplayer with a minimum of 2 and maximum of 6 players. (Priority: 1)
Players should be able to create or join game lobbies to start a multiplayer session. (Priority: 1)
Players must be able to assign unique visible names so that their avatars and chat messages are identifiable. (Priority 2)
Player Interaction & Communication
Collaboration should be facilitated between players by generating orders that players can work on together. (Priority: 1)
Players must be able to see and monitor each other's avatars. (Priority: 1)
Players should be able to interact with (e.g. push/block/bump) each other's avatars. (Priority: 3)
A chat system should be implemented for players to communicate during 30-second 'Stand up Scrum meetings' at the start of each day, and at the end of each day for the sprint review. (Priority: 2)
Gameplay Mechanics
Players must be able to move their avatar around the game map using arrow keys and mouse control. (Priority: 1)
The game must display a top-down, 2D kitchen at the start of each day, with clearly defined cooking stations. (Priority: 1)
The game must implement walls confining players within the map, and if moving rooms are included, walls must confine players within their room. (Priority: 1)
Game objects like ingredients, knives, pots, and plates must be able to be picked up, used, and put down by players. (Priority: 1)
Tools like knives, pots, packages, and inspection tools should be assigned a length of time for their usage, displayed with a visible progress bar showing how much longer the player has to wait until they are finished. (Priority: 2)
Tools should change the visible state of food (e.g., food becomes darker when cooked). (Priority: 2)
Scrum & Task Management
The game must simulate a product backlog by generating varying order recipes for the players to complete at the start of each day. (Priority: 1)
Recipes should disappear once completed. (Priority: 3)
The day must end when the timer hits 5 minutes, or when all orders have been completed. (Priority: 1)
Timers must record how long it takes to complete each order, so these stats can be presented to players during the sprint review. (Priority: 3)
The accuracy of each order must also be recorded and presented to the players at the end of each day in the sprint review. (Priority: 3)
User Feedback
The game should provide feedback to users for their actions (e.g., sound effects, animations). (Priority: 3)
						                                    
NON-FUNCTIONAL REQUIREMENTS:
Performance & Compatibility
The game should run on most popular operating systems, including ECS lab computers and first-year student laptops. (Priority: 1)
The game should run at a minimum of 30fps on standard modern computers. (Priority: 2)
Cybersecurity
The game should be cyber-secure by ensuring assigned character names and chat history are deleted once the session is closed. (Priority: 3)
Any chat messages and player names stored for the duration of the game should be encrypted and only accessible by players in the lobby. (Priority: 3)
Aesthetic & Design
The game should have a consistent and appealing visual style that enhances the gameplay experience without distracting from the functionality. (Priority: 3)
Assets used in the game will be chosen with the purpose of sharing a consistent colour scheme in mind. (Priority: 3)
The wall tiles, tables, chairs etc will be chosen to resemble a restaurant kitchen. (Priority: 3)



DOMAIN DESIGN

Early Prototype
https://coolrobotmonkey.itch.io/cooked
An early prototype of the game linked above has been developed above to test the domain design specifications. The prototype has implemented the following components:
Player
WASD Movement has been implemented
Collision has been implemented between the player and the walls and the stove.
The player can pick up the pan off of the floor and place the pan on the stove or on the ground
The player rotates towards the direction of the crosshair.
Game Controller
Sets the state between gameplay and title screen.
Title screen
A simple title screen has been implemented.
Pan
A pan the player can pick up has been implemented.
The player cannot pick up the pan if they are too far away.
Stove
A stove the player can place the pan on has been implemented.
The player cannot place the pan on the stove if they are too far away.
Crosshair
A simple crosshair has been implemented.

Design Architecture
https://lucid.app/lucidchart/cfa0b525-ef21-4187-99b2-8b2b6bcdd577/edit?viewport_loc=-2040%2C343%2C3677%2C1783%2C0_0&invitationId=inv_dd5e9e16-6025-405a-91a5-a4bcd63e01d8
The UML Class Diagram linked above has been created to visualise the intended system architecture for the game.
Since we are creating this game in Unity, the “Classes” are C# scripts attached to Game Objects.
Some of Unity’s built-in functions like “SceneManager.LoadScene()” or “Time.timeScale” are used within scripts. These have been visualised in the diagram.
We are using Unity’s Scenes to design our game. Scenes are environments where Game Objects can exist. The Game Controller controls which Scene the game is in e.g. switch from “Title Screen” to “Gameplay”. These scenes have been visualised in the diagram.
The diagram includes several gameplay objects such as “Stove”, “Patty”, “Pan”. As ideas develop, more gameplay objects may be added later on and their designs specified. Due to this, the diagram is subject to change.
The current system architecture includes 5 different classes/scripts for ingredients: “Patty”, “Bun”, “Lettuce”, “Tomato” and “Cheese”. A simplification may be made in the future to consolidate these into one class/script: “Ingredient”. This proposed simplification will have to be tested in a future prototype.

Domain design components descriptions
Player - The component representing the player’s avatar. Each player will have their own player object.
Game Controller - Controls game state. Keeps track of game score. 
Crosshair - Visible crosshair instead of mouse.
Fridge - Holds ingredients. Player can take ingredients from the fridge.
Patty - Ingredient for burgers. Can be cooked on the stove.
Ingredients - Bun/Lettuce/Tomato/Cheese. Ingredients for burgers.
Pan - Can be picked up and put down. Can be placed on the stove. Patty can be cooked on the pan.
Stove - Pan can be placed on the stove to cook patties.
Title screen - Settings, host/join, quit game etc.
End screen - Displays score. Restart or quit options.
Multiplayer - Controls multiplayer functionality.
Fuzz-Testing - Controls tests.
Pause menu - Pauses game. Options e.g. settings, quit game.

Design Flow
https://www.figma.com/board/iNI5RXbZx8CwTT5ds1bgos/New-game-flow?node-id=0-1&t=SJSzgwqe0Vaq4ssm-0
The game system will follow the flowchart linked above. The “Play Game” stage will align with the specifications listed in Requirements - Gameplay mechanics/Scum & Task Management.




GUI DESIGN
Game Flow: https://www.figma.com/board/iNI5RXbZx8CwTT5ds1bgos/New-game-flow?node-id=0-1&t=81yTsG2H9QnVUgLx-0

The system architecture is focused on how users interact with the game interface and how the GUI components communicate with other parts of the system. The goal is to create a seamless and intuitive experience that allows players to easily navigate the game while also supporting the backend functionality. Here’s a breakdown of the key components and interfaces with external systems.
1. Frontend GUI Components
The frontend serves as the player-facing part of the system. It consists of various UI components, each designed to fulfil a specific role in the gameplay experience. These components communicate with the backend through APIs, WebSockets, and event listeners. Key frontend components include:
a. Start Screen
Purpose: Provides entry to the game, featuring the “Play” button.
Design Choice: Simple, clean design to reduce friction in accessing the core gameplay.
Requirements: Responsive to multiple device types (desktop and laptop) and screen sizes.
b. Main Menu
Lobby Interface: Allows players to join or create a game.
Design Choice: Clear list of available rooms with a “Join lobby” button and the option to create a new lobby “Create game”. Feedback is provided when a player successfully joins.
Constraints: The design needs to accommodate dynamic player lists and must be able to handle real-time updates when players join or leave.
External Interface: Requires real-time communication with the backend server to display and update lobby statuses.
Start the Game: Initiates the game after all players are ready.
Design Choice: The button is only enabled when all players confirm their readiness.
Constraint: Backend must verify player status before enabling this button.
c. In-Game HUD (Head-Up Display)
Purpose: Displays real-time information such as task lists, timers, scores, and player statuses.
Design Choice: Minimalist approach to ensure clarity while keeping players focused on gameplay. Non-intrusive pop ups are used for status changes (e.g., “Order Ready”).
Requirements: The HUD must update dynamically based on game events, requiring smooth interaction with backend game state data.
d. Pause Menu
Purpose: Allows players to temporarily halt the game, adjust settings, or exit to the main menu.
Design Choice: Simple overlay to pause the game without interrupting the background view of the current state.
Interface: Direct communication with the backend game state to pause, resume, or exit the game session.
e. Settings Menu
Purpose: Lets players customise controls, graphics, and audio.
Design Choice: Segmented into categories for easy navigation.
Requirements: Must save changes locally or remotely and ensure smooth transition when changes are applied.
f. End Screen
Purpose: Displays final scores and game outcomes.
Design Choice: Celebration animations for the winning team and options to restart or return to the Start Screen.
Interface: Triggers backend to end the session and reset game state


2. Design Requirements and Constraints
Responsiveness: All UI components must be flexible and adapt to various screen sizes and device types, ensuring that players have a consistent experience regardless of their device.
Performance Constraints: The GUI should be lightweight and optimised to avoid long load times or lag, particularly during gameplay. Resource-intensive elements, like animations, should be minimised.
Usability: The GUI must follow established principles of game design, focusing on ease of use and accessibility. Players should intuitively understand navigation, task progression, and how to interact with different parts of the interface.

	3. Prototyping and Testing
To ensure feasibility of the design, we have developed an early prototype using a wireframe tool (figma) and also created a design flow, which simulates the flow between different screens and game states. Key aspects tested include:
a. Navigation Flow
The wireframe allows testers to click through the Start Screen, Main Menu, Lobby, In-Game HUD, Pause Menu, Settings Menu, and End Screen. The prototype checks that the flow between these components was intuitive and easy to follow.
b. Responsiveness
The prototype was tested on different laptops and desktop to ensure that the UI adjusts dynamically. This early testing phase revealed areas where the layout needed further adjustment for smaller screens.
c. Real-Time Updates
To mimic real-time updates (e.g., players joining the lobby or in-game tasks changing). Tests will be created to confirm that the GUI can handle frequent updates without overwhelming users or causing visual clutter.
d. Performance
The early prototype focused on minimising load times and maintaining high FPS during gameplay. While the current prototype isn’t fully optimised, it has demonstrated the usability of the design, with acceptable performance on mid-range devices.




REFERENCES

[1] “Which Software Development Methodologies are the Most Popular,” Koombea, Feb. 05, 2024. https://www.koombea.com/blog/software-development-methodologies/
[2] “2013 IT Project Success Rates Survey Results – AmbySoft.com.” https://www.ambysoft.com/surveys/success2013.html
[3] J. Flynn, “16 Agile Statistics [2022]: What You Need To Know About Agile Project Management – Zippia,” ZIPPIA, Nov. 27, 2022. https://www.zippia.com/advice/agile-statistics/
[4] L. Cunningham, “8 Reasons Why Agile Projects Fail,” Agile Alliance, Apr. 30, 2015. https://www.agilealliance.org/8-reasons-why-agile-projects-fail/
[5] Unity Technologies, “Learn | Unity,” Unity, 2019. https://unity.com/learn
[6] “5 Best Programming Languages for Game Development - App Academy,” www.appacademy.io. https://www.appacademy.io/blog/best-programming-languages-for-game-development
[7] “About Netcode for GameObjects | Unity Multiplayer Networking,” docs-multiplayer.unity3d.com, Aug. 02, 2023. https://docs-multiplayer.unity3d.com/netcode/current/about/
[8] “What are the most popular game development methods? | 5 Answers from Research papers,” SciSpace - Question. https://typeset.io/questions/what-are-the-most-popular-game-development-methods-2r9yyvss3l
[9] “Game On: How Agile Practices Can Level Up Your Game Development,” www.linkedin.com. https://www.linkedin.com/pulse/game-how-agile-practices-can-level-up-your-development-playaxis/
[10] “25 Agile Games to improve team performance and collaboration,” SessionLab, Jul. 26, 2023. https://www.sessionlab.com/blog/agile-games-and-activities/
[11] Itch.zone, 2024. https://img.itch.zone/aW1nLzU3MDM5ODIucG5n/original/gppHxF.png (accessed Aug. 15, 2024).
[12] “Kitchen Utensils 8x8 and 16x16,” itch.io, 2024. https://katame13.itch.io/kitchen-utensils (accessed Aug. 15, 2024). 
[13] “150+ Food Icon Pack,” @UnityAssetStore, 2024. https://assetstore.unity.com/packages/2d/gui/icons/150-food-icon-pack-210976 (accessed Aug. 15, 2024).
[14] L. Cluster, “Top 8 Agile Games for Boosting Team Performance,” Invensis Learning Blog, Jan. 10, 2024. https://www.invensislearning.com/blog/best-agile-games/ (accessed Aug. 15, 2024). 
[15] “5 Agile Games for Innovative Learning,” Easy Agile. https://www.easyagile.com/blog/agile-games/
[16] #play14, “#play14 Luxembourg 2015 - Ball Point Game, a classic,” YouTube, Mar. 28, 2015. https://www.youtube.com/watch?v=68ufFMpuXpY (accessed Aug. 15, 2024).
